派生类可以不重写虚函数，这个是你自己看

基类的指针和引用不过是指向派生类的基类部分
A a;
B b;
A *p=&b;  //指向派生类对象的基类部分

派生类的基类部分还是(要调用基类构造函数)初始化，后面又说最好不要这样做，到底支持不支持？
派生类初始化基类就在(初始化列表)调用人家构造函数，有个时间先后顺序

虽然继承了，但是能不能访问还不一定，看此时成员的限定符

派生声明是class B;不是class B: public A;
class A
{
};
class B:public A
{}  
才对，不能直接声明A，即class A;因为B要用到A里的东西，需要知道A里的东西是啥？

有个静态类型和动态类型：
因为派生类含有基类部分，不存在反向转换，即:
A a;
B *b = &a; //xxx

B b;
A *a = &b;
B *b = a; // xxx，编译器只能编译时检查正常不，所以判断为错误。如果基类又虚函数，可以dynacmic_cast启动运行时检查；或者觉得肯定正常可以直接用static_cast强转
