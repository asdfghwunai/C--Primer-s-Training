15-1 函数形参里有基类指针 或引用时，调用虚函数时动态绑定(由传进来的实参对象类型决定)
void func(const A& obj)
{
   obj.fun1(); //fun1()不是虚函数的话，就会一定调用基类的函数;是的话就动态绑定
   obj.fun2();
}

15-2 类型转换
静态类型是编译时就知道，动态类型是运行时才知道。。。
只有基类的指针和引用静态和动态可能不一致，静态就是形参，动态就是实参类型；
其他情况静态和动态是一致的，都是形参类型，可能发生实参类型向形参类型的转换

-------基类到派生类的什么转换都不行--------
指针和引用间的
A a;
B *bp=&a;    //xxx
B &bref=a;   //xxx

指针间
B b;
A *ap=&b;  //正确
B *bp=ap; //xxx，想间接成功，休想


实在想转可以dynamic_cast，帮你检查对不对；如果你确定没问题，可以static_cast，但是编译器不会帮检查。。

-----------派生类到基类对象没有类型转换，而是调用拷贝或赋值运算符，这会造成切割slice down----
B b;
A a(b); //调用拷贝
a=b;   //调用=
不存在基类对象到派生类的操作
