/*
参考https://blog.csdn.net/ljianhui/article/details/9245661

直接初始化就是调用某种参数的构造函数，拷贝初始化就是调用拷贝构造函数，可能在此之前会调用构造函数建立临时对象或普通对象
*/

//考虑一下编译器优化
ClassTest ct2 = "ab";

它本来是要这样来构造对象的：首先调用构造函数ClassTest(const char *pc)函数创建一个临时对象，然后调用复制构造函数，把这个临时对象作为参数，
构造对象ct2。然而编译也发现，复制构造函数是公有的，即你明确地告诉了编译器，你允许对象之间的复制，
而且此时它发现可以通过直接调用重载的构造函数ClassTest(const char *pc)来直接初始化对象，而达到相同的效果，
所以就把这条语句优化为ClassTest ct2（"ab"）。

而如果把复制构造函数声明为私有的，则对象之前的复制不能进行，即不能把临时对像作为参数，调用复制构造函数，
所以编译就认为ClassTest ct2 = "ab"与ClassTest ct2（"ab"）是不等价的，也就不会帮你做这个优化，所以编译出错了。
